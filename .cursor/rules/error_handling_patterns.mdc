Complete guide to error handling patterns and global error management

## Global Error Handling Architecture

The application uses a centralized error handling system with the `GlobalErrorHandler` service that provides consistent error management across all layers.

### Core Principles

1. **Centralized Error Types**: All custom errors extend from `ApiError` base class
2. **Consistent Error Handling**: Use `GlobalErrorHandler` for all error operations
3. **User-Friendly Messages**: Errors are automatically translated to user-friendly notifications
4. **Proper Error Propagation**: Errors bubble up through the layers with context
5. **Logging Integration**: All errors are logged with proper context

## Error Types

### Base Error Classes

```typescript
// Base API error with standard properties
export class ApiError extends Error {
  constructor(
    message: string,
    public code?: string,
    public statusCode?: number,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// Specific error types
export class NotFoundError extends ApiError {
  constructor(resource: string, id: string) {
    super(`${resource} with id ${id} not found`, 'NOT_FOUND', 404);
  }
}

export class ValidationError extends ApiError {
  constructor(message: string, details?: any) {
    super(message, 'VALIDATION_ERROR', 400, details);
  }
}

export class NetworkError extends ApiError {
  constructor(message: string = 'Network connection failed') {
    super(message, 'NETWORK_ERROR', 0);
  }
}

export class AuthenticationError extends ApiError {
  constructor(message: string = 'Authentication failed') {
    super(message, 'AUTH_ERROR', 401);
  }
}

export class AuthorizationError extends ApiError {
  constructor(message: string = 'Access denied') {
    super(message, 'AUTHORIZATION_ERROR', 403);
  }
}
```

## API Layer Error Handling

### Standard Pattern for API Methods

```typescript
@Injectable({ providedIn: 'root' })
export class ExampleApi {
  private supabase = inject(SupabaseClient);
  private errorHandler = inject(GlobalErrorHandler);

  async getData(): Promise<DataType[]> {
    try {
      const { data, error } = await this.supabase
        .from('table')
        .select('*');

      if (error) {
        throw this.errorHandler.createApiError(error, 'fetch data');
      }

      return data || [];
    } catch (error) {
      // Re-throw ApiError instances, wrap others
      if (error instanceof ApiError) throw error;
      throw this.errorHandler.createApiError(error, 'fetch data');
    }
  }

  async getById(id: string): Promise<DataType | null> {
    try {
      const { data, error } = await this.supabase
        .from('table')
        .select('*')
        .eq('id', id)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null; // Not found
        }
        throw this.errorHandler.createApiError(error, `fetch item with id ${id}`);
      }

      return data;
    } catch (error) {
      if (error instanceof ApiError) throw error;
      throw this.errorHandler.createApiError(error, `fetch item with id ${id}`);
    }
  }

  async create(item: CreateType): Promise<DataType> {
    try {
      const { data, error } = await this.supabase
        .from('table')
        .insert(item)
        .select()
        .single();

      if (error) {
        throw this.errorHandler.createApiError(error, 'create item');
      }

      return data;
    } catch (error) {
      if (error instanceof ApiError) throw error;
      throw this.errorHandler.createApiError(error, 'create item');
    }
  }
}
```

## Service Layer Error Handling

### Error Handling in Services

```typescript
@Injectable({ providedIn: 'root' })
export class ExampleService {
  private api = inject(ExampleApi);
  private errorHandler = inject(GlobalErrorHandler);

  readonly data = signal<DataType[]>([]);
  readonly loading = signal(false);
  readonly error = signal<string | null>(null);

  async loadData(): Promise<void> {
    this.loading.set(true);
    this.error.set(null);

    try {
      const result = await this.api.getData();
      this.data.set(result);
    } catch (error) {
      const errorMessage = this.errorHandler.getErrorMessage(error);
      this.error.set(errorMessage);
      
      // Also handle globally for user notification
      this.errorHandler.handleError(error, 'Loading data');
    } finally {
      this.loading.set(false);
    }
  }

  async createItem(item: CreateType): Promise<void> {
    try {
      const newItem = await this.api.create(item);
      this.data.update(items => [...items, newItem]);
    } catch (error) {
      this.errorHandler.handleError(error, 'Creating item');
      throw error; // Re-throw for component handling
    }
  }
}
```

## Component Layer Error Handling

### Error Handling in Components

```typescript
@Component({
  selector: 'app-example',
  template: `
    @if (service.error()) {
      <div class="error-message">
        {{ service.error() }}
      </div>
    }
    
    @if (service.loading()) {
      <div>Loading...</div>
    } @else {
      <!-- Component content -->
    }
  `
})
export class ExampleComponent {
  service = inject(ExampleService);
  errorHandler = inject(GlobalErrorHandler);

  async handleAction(): Promise<void> {
    try {
      await this.service.performAction();
    } catch (error) {
      // Error is already handled by service and global handler
      // Component can perform additional cleanup or navigation
      console.log('Action failed, handled by global error handler');
    }
  }
}
```

## Global Error Handler Usage

### Injecting and Using GlobalErrorHandler

```typescript
// In any service or component
export class MyService {
  private errorHandler = inject(GlobalErrorHandler);

  async performOperation(): Promise<void> {
    try {
      // Some operation that might fail
      await this.api.doSomething();
    } catch (error) {
      // Handle error with context
      this.errorHandler.handleError(error, 'Performing operation');
      throw error; // Re-throw if needed
    }
  }

  // Check error types
  isNotFoundError(error: unknown): boolean {
    return this.errorHandler.isErrorType(error, NotFoundError);
  }

  // Get user-friendly error message
  getErrorMessage(error: unknown): string {
    return this.errorHandler.getErrorMessage(error);
  }
}
```

## Error Handling Rules

### 1. API Layer Rules
- **Always use try-catch** around Supabase operations
- **Check for specific error codes** (e.g., PGRST116 for not found)
- **Use GlobalErrorHandler.createApiError()** to wrap unknown errors
- **Re-throw ApiError instances** without modification
- **Return null for not found** instead of throwing (when appropriate)

### 2. Service Layer Rules
- **Update signal state** with error information
- **Call GlobalErrorHandler.handleError()** for user notifications
- **Provide context** in error handling calls
- **Re-throw errors** when component needs to handle them

### 3. Component Layer Rules
- **Display error states** from service signals
- **Don't duplicate error handling** - let global handler manage notifications
- **Handle cleanup** or navigation on error when needed
- **Use async/await** properly in component methods

### 4. Error Message Standards
- **Use descriptive context** in error messages
- **Include operation names** in error context
- **Avoid technical jargon** in user-facing messages
- **Provide actionable information** when possible

## Common Patterns

### Resource Not Found Pattern
```typescript
async getResource(id: string): Promise<Resource | null> {
  try {
    const { data, error } = await this.supabase
      .from('resources')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return null; // Not found - return null instead of throwing
      }
      throw this.errorHandler.createApiError(error, `fetch resource ${id}`);
    }

    return data;
  } catch (error) {
    if (error instanceof ApiError) throw error;
    throw this.errorHandler.createApiError(error, `fetch resource ${id}`);
  }
}
```

### Validation Error Pattern
```typescript
async validateAndCreate(data: any): Promise<Resource> {
  // Validate input
  if (!data.name || data.name.trim().length === 0) {
    throw new ValidationError('Name is required');
  }

  if (data.email && !this.isValidEmail(data.email)) {
    throw new ValidationError('Invalid email format');
  }

  // Proceed with creation
  return this.createResource(data);
}
```

### Network Error Pattern
```typescript
async fetchWithRetry<T>(operation: () => Promise<T>): Promise<T> {
  const maxRetries = 3;
  let lastError: unknown;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      
      if (attempt === maxRetries) {
        throw new NetworkError(`Operation failed after ${maxRetries} attempts`);
      }
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
    }
  }

  throw lastError;
}
```

## Best Practices

### ✅ Do
- Use specific error types for different scenarios
- Provide meaningful error messages with context
- Handle errors at the appropriate layer
- Log errors for debugging purposes
- Use the global error handler for consistency

### ❌ Don't
- Catch errors and ignore them silently
- Show technical error messages to users
- Duplicate error handling logic
- Throw generic Error instances
- Handle the same error in multiple places

## Testing Error Scenarios

### Mocking Errors in Tests
```typescript
describe('ExampleApi', () => {
  let api: ExampleApi;
  let mockSupabase: jasmine.SpyObj<SupabaseClient>;

  beforeEach(() => {
    // Setup mocks
  });

  it('should handle not found errors', async () => {
    mockSupabase.from.and.returnValue({
      select: () => ({ single: () => Promise.resolve({ 
        data: null, 
        error: { code: 'PGRST116', message: 'Not found' } 
      })})
    });

    const result = await api.getById('non-existent-id');
    expect(result).toBeNull();
  });

  it('should throw ApiError for other errors', async () => {
    mockSupabase.from.and.returnValue({
      select: () => ({ single: () => Promise.resolve({ 
        data: null, 
        error: { code: 'PGRST001', message: 'Database error' } 
      })})
    });

    await expectAsync(api.getById('test-id'))
      .toBeRejectedWith(ApiError);
  });
});
```

This comprehensive error handling system ensures consistent, user-friendly error management across the entire application while maintaining proper error propagation and logging.