---
description: Service layer patterns for Signals-based state and business logic
globs:
alwaysApply: false
---

Services manage state with Signals and contain business logic. Review `coding_patterns.mdc` before applying these rules.

## Service Architecture Rules

1. Inject only the corresponding API (`*.api.ts`) for data access
2. Keep state in Signals using `resource()` or `rxResource()` when needed
3. Separate resources for collections (list/previews) and selected item (details)
4. Expose only the Signals and actions needed by the component
5. Consolidate loading and error state in computed Signals
6. Apply optimistic updates when it matches domain requirements

## Resource Selection Rules

**Rule 1:** use `rxResource` when wrapping Promises with `from()`

**Rule 2:** prefer `resource()` for direct async calls

**Rule 3:** use `toSignal()` only for simple observable conversions

```typescript
// rxResource pattern (for Promise-based APIs wrapped with from())
private readonly listResource = rxResource({
  stream: () => from(this.api.getUsers(this.searchTerm())),
});

// resource() pattern (for direct Promise-based APIs)
private readonly listResource = resource({
  request: () => ({ search: this.searchTerm() }),
  loader: ({ search }) => this.api.getUsers(search),
});
```

## Signal Simplification Rules

**Rule 4:** consolidate loading/error flags into single `computed()` Signals

**Rule 5:** keep internal state private; expose only what the component consumes

```typescript
// ❌ Avoid multiple signals
readonly isLoading = computed(() => this.listResource.isLoading());
readonly isDetailsLoading = computed(() => this.detailsResource.isLoading());
readonly error = computed(() => this.listResource.error());
readonly detailsError = computed(() => this.detailsResource.error());

// ✅ Use consolidated signals
readonly isLoading = computed(
  () => this.listResource.isLoading() || this.detailsResource.isLoading()
);
readonly error = computed(
  () => this.listResource.error() || this.detailsResource.error()
);

// ✅ Private internal state
private readonly selectedId = signal<string | null>(null);
readonly searchTerm = signal<string>(''); // Public for external control
```

## Service Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class UserService {
  // Dependencies
  private api = inject(UserApi);
  private errorHandler = inject(GlobalErrorHandler);
  private notificationService = inject(NotificationService);

  // State management
  private readonly selectedId = signal<string | null>(null);
  readonly searchTerm = signal<string>('');

  // Resources
  private readonly listResource = rxResource({
    stream: () => from(this.api.getUsers(this.searchTerm())),
  });

  private readonly detailsResource = rxResource({
    stream: () => {
      const id = this.selectedId();
      return id ? from(this.api.getUserById(id)) : from(new Promise(() => {}));
    },
  });

  // Public signals - consolidated
  readonly users = computed(() => this.listResource.value() || []);
  readonly selectedUser = computed(() => this.detailsResource.value());
  readonly isLoading = computed(
    () => this.listResource.isLoading() || this.detailsResource.isLoading()
  );
  readonly error = computed(
    () => this.listResource.error() || this.detailsResource.error()
  );

  // Actions
  selectById(id: string): void {
    this.selectedId.set(id);
  }

  search(term: string): void {
    this.searchTerm.set(term);
  }

  async createUser(user: UserCreate): Promise<User> {
    try {
      const newUser = await this.api.createUser(user);
      this.notificationService.success('User created successfully');
      return newUser;
    } catch (error) {
      this.errorHandler.handleError(error, 'Creating user');
      throw error;
    }
  }

  async updateUser(id: string, user: UserUpdate): Promise<User> {
    try {
      const updatedUser = await this.api.updateUser(id, user);
      this.notificationService.success('User updated successfully');
      return updatedUser;
    } catch (error) {
      this.errorHandler.handleError(error, 'Updating user');
      throw error;
    }
  }

  async deleteUser(id: string): Promise<void> {
    try {
      await this.api.deleteUser(id);
      this.notificationService.success('User deleted successfully');
      
      if (this.selectedId() === id) {
        this.selectedId.set(null);
      }
    } catch (error) {
      this.errorHandler.handleError(error, 'Deleting user');
      throw error;
    }
  }
}
```

### Related References
- `coding_patterns.mdc` – Global Signals and layering rules
- `error_handling_patterns.mdc` – Error handling and retry strategies
- `notification_patterns.mdc` – User feedback guidelines
- `services/service_test_reference.md` – Service testing examples
- `services/service_cache_reference.md` – Cache patterns
- `services/service_optmistic_reference.md` – Optimistic update strategies
