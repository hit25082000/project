---
description: Complete guide to create Services his patterns, state management with signals, and business logic organization
globs:
alwaysApply: false
---

Services manage application state using Angular Signals and handle all business logic. They act as the bridge between the presentation layer (components) and the data layer (APIs).

## Service Architecture Rules

1. Inject the corresponding `.api.ts` file. **Never inject `SupabaseClient` directly**
2. Manage state with signals, using a `resource`-like pattern for async data
3. Create separate resources for lists (`Preview` data) and selected items (`Details` data)
4. Expose public signals for components and methods for actions
5. Handle loading states and error management
6. Implement optimistic updates where appropriate

## Resource Selection Rules

**Rule 1: Use `rxResource` for Promise-based APIs wrapped with `from()`**
**Rule 2: Use `resource()` for direct Promise-based APIs**
**Rule 3: Use `toSignal()` for simple observable conversions**

```typescript
// rxResource pattern (for Promise-based APIs wrapped with from())
private readonly listResource = rxResource({
  stream: () => from(this.api.getUsers(this.searchTerm())),
});

// resource() pattern (for direct Promise-based APIs)
private readonly listResource = resource({
  request: () => ({ search: this.searchTerm() }),
  loader: ({ search }) => this.api.getUsers(search),
});
```

## Signal Simplification Rules

**Rule 4: Consolidate loading and error signals - use single signals for all resources**
**Rule 5: Make internal state private, expose only what components need**

```typescript
// ❌ Avoid multiple signals
readonly isLoading = computed(() => this.listResource.isLoading());
readonly isDetailsLoading = computed(() => this.detailsResource.isLoading());
readonly error = computed(() => this.listResource.error());
readonly detailsError = computed(() => this.detailsResource.error());

// ✅ Use consolidated signals
readonly isLoading = computed(
  () => this.listResource.isLoading() || this.detailsResource.isLoading()
);
readonly error = computed(
  () => this.listResource.error() || this.detailsResource.error()
);

// ✅ Private internal state
private readonly selectedId = signal<string | null>(null);
readonly searchTerm = signal<string>(''); // Public for external control
```

## Service Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class UserService {
  // Dependencies
  private api = inject(UserApi);
  private errorHandler = inject(GlobalErrorHandler);
  private notificationService = inject(NotificationService);

  // State management
  private readonly selectedId = signal<string | null>(null);
  readonly searchTerm = signal<string>('');

  // Resources
  private readonly listResource = rxResource({
    stream: () => from(this.api.getUsers(this.searchTerm())),
  });

  private readonly detailsResource = rxResource({
    stream: () => {
      const id = this.selectedId();
      return id ? from(this.api.getUserById(id)) : from(new Promise(() => {}));
    },
  });

  // Public signals - consolidated
  readonly users = computed(() => this.listResource.value() || []);
  readonly selectedUser = computed(() => this.detailsResource.value());
  readonly isLoading = computed(
    () => this.listResource.isLoading() || this.detailsResource.isLoading()
  );
  readonly error = computed(
    () => this.listResource.error() || this.detailsResource.error()
  );

  // Actions
  selectById(id: string): void {
    this.selectedId.set(id);
  }

  search(term: string): void {
    this.searchTerm.set(term);
  }

  async createUser(user: UserCreate): Promise<User> {
    try {
      const newUser = await this.api.createUser(user);
      this.notificationService.success('User created successfully');
      return newUser;
    } catch (error) {
      this.errorHandler.handleError(error, 'Creating user');
      throw error;
    }
  }

  async updateUser(id: string, user: UserUpdate): Promise<User> {
    try {
      const updatedUser = await this.api.updateUser(id, user);
      this.notificationService.success('User updated successfully');
      return updatedUser;
    } catch (error) {
      this.errorHandler.handleError(error, 'Updating user');
      throw error;
    }
  }

  async deleteUser(id: string): Promise<void> {
    try {
      await this.api.deleteUser(id);
      this.notificationService.success('User deleted successfully');
      
      if (this.selectedId() === id) {
        this.selectedId.set(null);
      }
    } catch (error) {
      this.errorHandler.handleError(error, 'Deleting user');
      throw error;
    }
  }
}
```

### Error Handling
- **Error Handling**: See `error_handling_patterns.md` 
- **Notifications**: See `notification_patterns`

### Reference Documentation (READ ONLY IF NEEDED)
- **Detailed Error Handling and Retry**: See `service_error_reference.md` 
- **Detailed Testing Examples**: See `service_test_reference.md`
- **Optimistic Patterns**: See `service_optmistic_reference.md`
- **Cache Patterns**: See `service_cache_reference.md`
