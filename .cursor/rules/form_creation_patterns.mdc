---
description: Form creation patterns and dynamic form configuration standards
globs:
alwaysApply: false
---

# Form Creation Patterns

All forms should be built using the reusable `<v-dynamic-form>` component to standardize creation and maintain consistency across the application.

## Form Creation Pattern

1. **Define a Configuration Constant**: In a `[form-name].constant.ts` file, create a function that returns the form's configuration array.
2. **Pass Config to Component**: In your component's template, pass the configuration to the `<v-dynamic-form>`.

### Example Implementation

```typescript
// establishment-info.constant.ts
export const ESTABLISHMENT_INFO_FORM_CONFIG = (): iDynamicFormConfig[] => {
  return [
    {
      label: 'Establishment Name',
      name: 'name',
      type: { field: eDynamicField.INPUT },
      validations: [Validators.required],
    },
    {
      label: 'Description',
      name: 'description',
      type: { field: eDynamicField.TEXTAREA },
      validations: [Validators.required, Validators.minLength(10)],
    },
    {
      label: 'Category',
      name: 'category',
      type: { field: eDynamicField.SELECT },
      options: [
        { value: 'restaurant', label: 'Restaurant' },
        { value: 'hotel', label: 'Hotel' },
        { value: 'shop', label: 'Shop' }
      ],
      validations: [Validators.required],
    },
    {
      label: 'Is Active',
      name: 'isActive',
      type: { field: eDynamicField.CHECKBOX },
      defaultValue: true,
    },
    // ... other form fields
  ];
};

// establishment-info-form.component.ts
@Component({
  template: `<v-dynamic-form [config]="formConfig" (formSubmit)="onFormSubmit($event)"></v-dynamic-form>`
})
export class EstablishmentInfoFormComponent {
  readonly formConfig = ESTABLISHMENT_INFO_FORM_CONFIG();
  
  onFormSubmit(formData: any): void {
    // Handle form submission
  }
}
```

## Form Configuration Standards

### Field Types
- Use `eDynamicField.INPUT` for text inputs
- Use `eDynamicField.TEXTAREA` for multiline text
- Use `eDynamicField.SELECT` for dropdown selections
- Use `eDynamicField.CHECKBOX` for boolean values
- Use `eDynamicField.DATE` for date inputs
- Use `eDynamicField.NUMBER` for numeric inputs

### Validation Patterns
- Always include `Validators.required` for mandatory fields
- Use `Validators.minLength()` and `Validators.maxLength()` for text fields
- Use `Validators.email()` for email fields
- Use `Validators.pattern()` for custom validation rules
- Use `Validators.min()` and `Validators.max()` for numeric fields

### Form Naming Convention
- Form constants: `[FEATURE]_[PURPOSE]_FORM_CONFIG`
- Example: `ESTABLISHMENT_INFO_FORM_CONFIG`, `USER_PROFILE_FORM_CONFIG`

### Component Naming Convention
- Form components: `[feature]-[purpose]-form.component.ts`
- Example: `establishment-info-form.component.ts`, `user-profile-form.component.ts`

## Advanced Form Patterns

### Conditional Fields
```typescript
{
  label: 'Phone Number',
  name: 'phone',
  type: { field: eDynamicField.INPUT },
  validations: [Validators.required],
  showWhen: (formData: any) => formData.contactMethod === 'phone'
}
```

### Dynamic Options
```typescript
{
  label: 'City',
  name: 'city',
  type: { field: eDynamicField.SELECT },
  options: (formData: any) => getCitiesByState(formData.state),
  validations: [Validators.required],
}
```

### Custom Validation Messages
```typescript
{
  label: 'Email',
  name: 'email',
  type: { field: eDynamicField.INPUT },
  validations: [Validators.required, Validators.email],
  validationMessages: {
    required: 'Email is required',
    email: 'Please enter a valid email address'
  }
}
```