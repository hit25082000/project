---
description: Angular 20 routing patterns with enhanced scroll options and child resolvers
globs:
alwaysApply: false
---

# Angular 20 Routing Patterns

Angular 20 enhances routing capabilities with new scroll options for `ViewportScroller.scrollToAnchor()` and `scrollToPosition()` methods, plus child resolvers that can access parent route data.

## Enhanced Scroll Options

### ViewportScroller with Options
```typescript
// Enhanced scroll methods with options
@Injectable({ providedIn: 'root' })
export class ScrollService {
  private viewportScroller = inject(ViewportScroller);
  
  scrollToAnchor(anchor: string, options?: ScrollToOptions): void {
    this.viewportScroller.scrollToAnchor(anchor, options);
  }
  
  scrollToPosition(position: [number, number], options?: ScrollToOptions): void {
    this.viewportScroller.scrollToPosition(position, options);
  }
  
  // Smooth scrolling to element
  scrollToElementSmooth(elementId: string): void {
    this.scrollToAnchor(elementId, {
      behavior: 'smooth',
      block: 'start',
      inline: 'nearest'
    });
  }
  
  // Scroll to top with smooth animation
  scrollToTop(): void {
    this.scrollToPosition([0, 0], {
      behavior: 'smooth'
    });
  }
}
```

### Component with Scroll Integration
```typescript
@Component({
  template: `
    <nav class="page-nav">
      <button (click)="scrollToSection('intro')">Introduction</button>
      <button (click)="scrollToSection('features')">Features</button>
      <button (click)="scrollToSection('contact')">Contact</button>
    </nav>
    
    <main class="page-content">
      <section id="intro" class="page-section">
        <h2>Introduction</h2>
        <p>Welcome to our application...</p>
      </section>
      
      <section id="features" class="page-section">
        <h2>Features</h2>
        <p>Our key features include...</p>
      </section>
      
      <section id="contact" class="page-section">
        <h2>Contact</h2>
        <p>Get in touch with us...</p>
      </section>
    </main>
  `
})
export class ScrollablePageComponent {
  private scrollService = inject(ScrollService);
  
  scrollToSection(sectionId: string): void {
    this.scrollService.scrollToElementSmooth(sectionId);
  }
}
```

## Child Resolvers with Parent Data Access

### Parent Route with Resolver
```typescript
// user.resolver.ts
@Injectable({ providedIn: 'root' })
export class UserResolver implements Resolve<User> {
  private userService = inject(UserService);
  
  resolve(route: ActivatedRouteSnapshot): Observable<User> {
    const userId = route.paramMap.get('id');
    if (!userId) {
      throw new Error('User ID is required');
    }
    return this.userService.getUserById(userId);
  }
}

// user-profile.resolver.ts - Child resolver accessing parent data
@Injectable({ providedIn: 'root' })
export class UserProfileResolver implements Resolve<UserProfile> {
  private profileService = inject(ProfileService);
  
  resolve(route: ActivatedRouteSnapshot): Observable<UserProfile> {
    // Access parent route data
    const parentData = route.parent?.data;
    const user = parentData?.['user'] as User;
    
    if (!user) {
      throw new Error('User data not available from parent route');
    }
    
    return this.profileService.getProfileByUserId(user.id);
  }
}
```

### Route Configuration with Resolvers
```typescript
// app.routes.ts
export const routes: Routes = [
  {
    path: 'users',
    children: [
      {
        path: ':id',
        resolve: { user: UserResolver }, // Parent resolver
        children: [
          {
            path: '',
            component: UserDetailsComponent,
            resolve: { profile: UserProfileResolver }, // Child resolver
            children: [
              {
                path: 'settings',
                component: UserSettingsComponent,
                resolve: { settings: UserSettingsResolver } // Grandchild resolver
              }
            ]
          }
        ]
      }
    ]
  }
];
```

### Component Accessing Resolved Data
```typescript
@Component({
  template: `
    <div class="user-details">
      <h1>{{ user().name }}</h1>
      <div class="profile-section">
        <h2>Profile</h2>
        <p>{{ profile().bio }}</p>
        <img [src]="profile().avatar" [alt]="user().name" />
      </div>
    </div>
  `
})
export class UserDetailsComponent {
  private route = inject(ActivatedRoute);
  
  // Access resolved data from both parent and current route
  user = signal<User>(this.route.snapshot.data['user']);
  profile = signal<UserProfile>(this.route.snapshot.data['profile']);
  
  ngOnInit(): void {
    // Subscribe to route data changes
    this.route.data.subscribe(data => {
      if (data['user']) {
        this.user.set(data['user']);
      }
      if (data['profile']) {
        this.profile.set(data['profile']);
      }
    });
  }
}
```

## Advanced Routing Patterns

### Lazy Loading with Preloading
```typescript
// app.routes.ts
export const routes: Routes = [
  {
    path: 'dashboard',
    loadComponent: () => import('./dashboard/dashboard.page').then(m => m.DashboardPage)
  },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.routes').then(m => m.adminRoutes),
    canActivate: [AdminGuard]
  },
  {
    path: '**',
    redirectTo: '/dashboard'
  }
];

// main.ts
bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, {
      preloadingStrategy: PreloadAllModules,
      enableTracing: false
    })
  ]
});
```

### Route Guards with Enhanced Capabilities
```typescript
@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate, CanActivateChild {
  private authService = inject(AuthService);
  private router = inject(Router);
  
  canActivate(route: ActivatedRouteSnapshot): boolean {
    return this.checkAuth(route);
  }
  
  canActivateChild(childRoute: ActivatedRouteSnapshot): boolean {
    return this.checkAuth(childRoute);
  }
  
  private checkAuth(route: ActivatedRouteSnapshot): boolean {
    const isAuthenticated = this.authService.isAuthenticated();
    
    if (!isAuthenticated) {
      // Store attempted URL for redirect after login
      this.router.navigate(['/login'], {
        queryParams: { returnUrl: route.url.map(segment => segment.path).join('/') }
      });
      return false;
    }
    
    return true;
  }
}

@Injectable({ providedIn: 'root' })
export class AdminGuard implements CanActivate {
  private authService = inject(AuthService);
  
  canActivate(): boolean {
    const user = this.authService.getCurrentUser();
    return user?.role === 'admin';
  }
}
```

### Route Data and Parameters
```typescript
@Component({
  template: `
    <div class="product-details">
      <h1>{{ product().name }}</h1>
      <p>Price: {{ product().price | currency }}</p>
      <div class="product-info">
        <p>{{ product().description }}</p>
      </div>
    </div>
  `
})
export class ProductDetailsComponent implements OnInit {
  private route = inject(ActivatedRoute);
  private productService = inject(ProductService);
  
  product = signal<Product | null>(null);
  
  ngOnInit(): void {
    // Get route parameters
    const productId = this.route.snapshot.paramMap.get('id');
    
    // Get query parameters
    const category = this.route.snapshot.queryParamMap.get('category');
    
    // Get route data
    const breadcrumb = this.route.snapshot.data['breadcrumb'];
    
    if (productId) {
      this.loadProduct(productId, category);
    }
  }
  
  private loadProduct(id: string, category?: string): void {
    this.productService.getProduct(id, category).subscribe(product => {
      this.product.set(product);
    });
  }
}
```

## Navigation Patterns

### Programmatic Navigation with State
```typescript
@Injectable({ providedIn: 'root' })
export class NavigationService {
  private router = inject(Router);
  private location = inject(Location);
  
  navigateToUser(userId: string, options?: NavigationExtras): void {
    this.router.navigate(['/users', userId], {
      queryParams: { tab: 'profile' },
      fragment: 'top',
      ...options
    });
  }
  
  navigateWithState(route: string[], state: any): void {
    this.router.navigateByUrl(this.router.createUrlTree(route), {
      state: state
    });
  }
  
  goBack(): void {
    this.location.back();
  }
  
  goForward(): void {
    this.location.forward();
  }
}
```

### Breadcrumb Service
```typescript
@Injectable({ providedIn: 'root' })
export class BreadcrumbService {
  private router = inject(Router);
  private route = inject(ActivatedRoute);
  
  readonly breadcrumbs = signal<Breadcrumb[]>([]);
  
  constructor() {
    this.router.events.pipe(
      filter(event => event instanceof NavigationEnd),
      distinctUntilChanged()
    ).subscribe(() => {
      this.buildBreadcrumbs();
    });
  }
  
  private buildBreadcrumbs(): void {
    const breadcrumbs: Breadcrumb[] = [];
    let route = this.route.root;
    
    while (route.firstChild) {
      route = route.firstChild;
      
      if (route.snapshot.data['breadcrumb']) {
        const breadcrumb: Breadcrumb = {
          label: route.snapshot.data['breadcrumb'],
          url: this.getRouteUrl(route),
          active: route === this.route
        };
        breadcrumbs.push(breadcrumb);
      }
    }
    
    this.breadcrumbs.set(breadcrumbs);
  }
  
  private getRouteUrl(route: ActivatedRoute): string {
    return route.snapshot.url.map(segment => segment.path).join('/');
  }
}
```

## Route Testing Patterns

### Testing Components with Routing
```typescript
describe('ProductDetailsComponent', () => {
  let component: ProductDetailsComponent;
  let fixture: ComponentFixture<ProductDetailsComponent>;
  let mockProductService: jasmine.SpyObj<ProductService>;
  
  beforeEach(async () => {
    mockProductService = jasmine.createSpyObj('ProductService', ['getProduct']);
    
    await TestBed.configureTestingModule({
      imports: [ProductDetailsComponent, RouterTestingModule],
      providers: [
        { provide: ProductService, useValue: mockProductService }
      ]
    }).compileComponents();
    
    fixture = TestBed.createComponent(ProductDetailsComponent);
    component = fixture.componentInstance;
  });
  
  it('should load product based on route parameters', () => {
    const mockProduct = { id: '1', name: 'Test Product', price: 100 };
    mockProductService.getProduct.and.returnValue(of(mockProduct));
    
    // Simulate route parameters
    TestBed.inject(ActivatedRoute).snapshot.paramMap = new Map([['id', '1']]);
    
    component.ngOnInit();
    
    expect(mockProductService.getProduct).toHaveBeenCalledWith('1', undefined);
    expect(component.product()).toEqual(mockProduct);
  });
});
```

### Testing Route Guards
```typescript
describe('AuthGuard', () => {
  let guard: AuthGuard;
  let mockAuthService: jasmine.SpyObj<AuthService>;
  let mockRouter: jasmine.SpyObj<Router>;
  
  beforeEach(() => {
    mockAuthService = jasmine.createSpyObj('AuthService', ['isAuthenticated']);
    mockRouter = jasmine.createSpyObj('Router', ['navigate']);
    
    TestBed.configureTestingModule({
      providers: [
        AuthGuard,
        { provide: AuthService, useValue: mockAuthService },
        { provide: Router, useValue: mockRouter }
      ]
    });
    
    guard = TestBed.inject(AuthGuard);
  });
  
  it('should allow access for authenticated users', () => {
    mockAuthService.isAuthenticated.and.returnValue(true);
    
    const result = guard.canActivate(new ActivatedRouteSnapshot());
    
    expect(result).toBeTrue();
  });
  
  it('should redirect unauthenticated users to login', () => {
    mockAuthService.isAuthenticated.and.returnValue(false);
    
    const result = guard.canActivate(new ActivatedRouteSnapshot());
    
    expect(result).toBeFalse();
    expect(mockRouter.navigate).toHaveBeenCalledWith(['/login']);
  });
});
```

## Best Practices

### Routing Do's
- Use lazy loading for feature modules
- Implement proper route guards
- Use resolvers for data loading
- Leverage child resolvers for nested data
- Use enhanced scroll options for better UX
- Implement breadcrumb navigation
- Test routing components and guards

### Routing Don'ts
- Don't load all modules upfront
- Don't forget to handle route errors
- Don't use complex logic in route guards
- Don't ignore route parameter validation
- Don't skip testing navigation logic
- Don't use hardcoded routes
- Don't forget to handle route state