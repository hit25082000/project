---
description: Routing patterns with enhanced scroll options and child resolvers
globs:
alwaysApply: false
---

Angular 20 routing patterns. Review `A-coding_patterns.mdc` for global principles and `template_syntax.mdc` for control-flow usage in pages.

## Enhanced Scroll Options

> See `C-component_patterns.mdc` for navigation within page components

### ViewportScroller with Options
```typescript
// Enhanced scroll methods with options
@Injectable({ providedIn: 'root' })
export class ScrollService {
  private viewportScroller = inject(ViewportScroller);
  
  scrollToAnchor(anchor: string, options?: ScrollToOptions): void {
    this.viewportScroller.scrollToAnchor(anchor, options);
  }
  
  scrollToPosition(position: [number, number], options?: ScrollToOptions): void {
    this.viewportScroller.scrollToPosition(position, options);
  }
  
  // Smooth scrolling to element
  scrollToElementSmooth(elementId: string): void {
    this.scrollToAnchor(elementId, {
      behavior: 'smooth',
      block: 'start',
      inline: 'nearest'
    });
  }
  
  // Scroll to top with smooth animation
  scrollToTop(): void {
    this.scrollToPosition([0, 0], {
      behavior: 'smooth'
    });
  }
}
```

### Component with Scroll Integration
```typescript
@Component({
  template: `
    <nav class="page-nav">
      <button (click)="scrollToSection('intro')">Introduction</button>
      <button (click)="scrollToSection('features')">Features</button>
      <button (click)="scrollToSection('contact')">Contact</button>
    </nav>
    
    <main class="page-content">
      <section id="intro" class="page-section">
        <h2>Introduction</h2>
        <p>Welcome to our application...</p>
      </section>
      
      <section id="features" class="page-section">
        <h2>Features</h2>
        <p>Our key features include...</p>
      </section>
      
      <section id="contact" class="page-section">
        <h2>Contact</h2>
        <p>Get in touch with us...</p>
      </section>
    </main>
  `
})
export class ScrollablePageComponent {
  private scrollService = inject(ScrollService);
  
  scrollToSection(sectionId: string): void {
    this.scrollService.scrollToElementSmooth(sectionId);
  }
}
```

## Child Resolvers with Parent Data Access

> Maintain shared data via services as per `C-service_patterns.mdc`

### Parent Route with Resolver
```typescript
// user.resolver.ts
@Injectable({ providedIn: 'root' })
export class UserResolver implements Resolve<User> {
  private userService = inject(UserService);
  
  resolve(route: ActivatedRouteSnapshot): Observable<User> {
    const userId = route.paramMap.get('id');
    if (!userId) {
      throw new Error('User ID is required');
    }
    return this.userService.getUserById(userId);
  }
}

// user-profile.resolver.ts - Child resolver accessing parent data
@Injectable({ providedIn: 'root' })
export class UserProfileResolver implements Resolve<UserProfile> {
  private profileService = inject(ProfileService);
  
  resolve(route: ActivatedRouteSnapshot): Observable<UserProfile> {
    // Access parent route data
    const parentData = route.parent?.data;
    const user = parentData?.['user'] as User;
    
    if (!user) {
      throw new Error('User data not available from parent route');
    }
    
    return this.profileService.getProfileByUserId(user.id);
  }
}
```

### Route Configuration with Resolvers
```typescript
// app.routes.ts
export const routes: Routes = [
  {
    path: 'users',
    children: [
      {
        path: ':id',
        resolve: { user: UserResolver }, // Parent resolver
        children: [
          {
            path: '',
            component: UserDetailsComponent,
            resolve: { profile: UserProfileResolver }, // Child resolver
            children: [
              {
                path: 'settings',
                component: UserSettingsComponent,
                resolve: { settings: UserSettingsResolver } // Grandchild resolver
              }
            ]
          }
        ]
      }
    ]
  }
];
```

### Component Accessing Resolved Data
```typescript
@Component({
  template: `
    <div class="user-details">
      <h1>{{ user().name }}</h1>
      <div class="profile-section">
        <h2>Profile</h2>
        <p>{{ profile().bio }}</p>
        <img [src]="profile().avatar" [alt]="user().name" />
      </div>
    </div>
  `
})
export class UserDetailsComponent {
  private route = inject(ActivatedRoute);
  
  // Access resolved data from both parent and current route
  user = signal<User>(this.route.snapshot.data['user']);
  profile = signal<UserProfile>(this.route.snapshot.data['profile']);
  
  ngOnInit(): void {
    // Subscribe to route data changes
    this.route.data.subscribe(data => {
      if (data['user']) {
        this.user.set(data['user']);
      }
      if (data['profile']) {
        this.profile.set(data['profile']);
      }
    });
  }
}
```

## Advanced Routing Patterns

> Align lazy loading and guards with `performance_optimization.mdc` and `error_handling_patterns.mdc`

### Lazy Loading with Preloading
```typescript
// app.routes.ts
export const routes: Routes = [
  {
    path: 'dashboard',
    loadComponent: () => import('./dashboard/dashboard.page').then(m => m.DashboardPage)
  },
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.routes').then(m => m.adminRoutes),
    canActivate: [AdminGuard]
  },
  {
    path: '**',
    redirectTo: '/dashboard'
  }
];

// main.ts
bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes, {
      preloadingStrategy: PreloadAllModules,
      enableTracing: false
    })
  ]
});
```

### Route Guards with Enhanced Capabilities
```typescript
@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate, CanActivateChild {
  private authService = inject(AuthService);
  private router = inject(Router);
  
  canActivate(route: ActivatedRouteSnapshot): boolean {
    return this.checkAuth(route);
  }
  
  canActivateChild(childRoute: ActivatedRouteSnapshot): boolean {
    return this.checkAuth(childRoute);
  }
  
  private checkAuth(route: ActivatedRouteSnapshot): boolean {
    const isAuthenticated = this.authService.isAuthenticated();
    
    if (!isAuthenticated) {
      // Store attempted URL for redirect after login
      this.router.navigate(['/login'], {
        queryParams: { returnUrl: route.url.map(segment => segment.path).join('/') }
      });
      return false;
    }
    
    return true;
  }
}

@Injectable({ providedIn: 'root' })
export class AdminGuard implements CanActivate {
  private authService = inject(AuthService);
  
  canActivate(): boolean {
    const user = this.authService.getCurrentUser();
    return user?.role === 'admin';
  }
}
```

### Route Data and Parameters
```typescript
@Component({
  template: `
    <div class="product-details">
      <h1>{{ product().name }}</h1>
      <p>Price: {{ product().price | currency }}</p>
      <div class="product-info">
        <p>{{ product().description }}</p>
      </div>
    </div>
  `
})
export class ProductDetailsComponent implements OnInit {
  private route = inject(ActivatedRoute);
  private productService = inject(ProductService);
  
  product = signal<Product | null>(null);
  
  ngOnInit(): void {
    // Get route parameters
    const productId = this.route.snapshot.paramMap.get('id');
    
    // Get query parameters
    const category = this.route.snapshot.queryParamMap.get('category');
    
    // Get route data
    const breadcrumb = this.route.snapshot.data['breadcrumb'];
    
    if (productId) {
      this.loadProduct(productId, category);
    }
  }
  
  private loadProduct(id: string, category?: string): void {
    this.productService.getProduct(id, category).subscribe(product => {
      this.product.set(product);
    });
  }
}
```

## Navigation Patterns

### Programmatic Navigation with State
```typescript
@Injectable({ providedIn: 'root' })
export class NavigationService {
  private router = inject(Router);
  private location = inject(Location);
  
  navigateToUser(userId: string, options?: NavigationExtras): void {
    this.router.navigate(['/users', userId], {
      queryParams: { tab: 'profile' },
      fragment: 'top',
      ...options
    });
  }
  
  navigateWithState(route: string[], state: any): void {
    this.router.navigateByUrl(this.router.createUrlTree(route), {
      state: state
    });
  }
  
  goBack(): void {
    this.location.back();
  }
  
  goForward(): void {
    this.location.forward();
  }
}
```

### Breadcrumb Service
```