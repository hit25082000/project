---
description: Angular 20 extended diagnostics and common error prevention patterns
globs:
alwaysApply: false
---

# Angular 20 Extended Diagnostics

Angular 20 introduces extended diagnostics to catch common mistakes early, such as missing directive imports and ambiguous expressions.

## Common Diagnostics

### Missing Directive Imports
```typescript
// ❌ Missing import - Angular 20 will catch this
@Component({
  template: `
    <div *ngIf="showContent">Content</div>
    <div *ngFor="let item of items">{{ item.name }}</div>
  `
})
export class ComponentWithMissingImports {
  showContent = true;
  items = [];
}

// ✅ Correct imports
@Component({
  template: `
    <div *ngIf="showContent">Content</div>
    <div *ngFor="let item of items">{{ item.name }}</div>
  `,
  imports: [CommonModule] // or NgIf, NgFor
})
export class ComponentWithCorrectImports {
  showContent = true;
  items = [];
}
```

### Ambiguous Expressions
```typescript
// ❌ Ambiguous expression - Angular 20 will warn
@Component({
  template: `
    <div>{{ user.name || user.displayName }}</div>
    <div>{{ items.filter(i => i.active).length }}</div>
  `
})
export class ComponentWithAmbiguousExpressions {
  user = signal({ name: '', displayName: '' });
  items = signal([]);
}

// ✅ Clear expressions
@Component({
  template: `
    <div>{{ getUserDisplayName() }}</div>
    <div>{{ activeItemsCount() }}</div>
  `
})
export class ComponentWithClearExpressions {
  user = signal({ name: '', displayName: '' });
  items = signal([]);
  
  getUserDisplayName(): string {
    const user = this.user();
    return user.name || user.displayName;
  }
  
  activeItemsCount(): number {
    return this.items().filter(i => i.active).length;
  }
}
```

## Directive Import Diagnostics

### Standalone Component Imports
```typescript
// ❌ Missing required imports
@Component({
  selector: 'app-user-card',
  template: `
    <form [formGroup]="userForm">
      <input formControlName="name" placeholder="Name">
      <button type="submit">Submit</button>
    </form>
  `,
  standalone: true
})
export class UserCardComponent {
  userForm = new FormGroup({
    name: new FormControl('')
  });
}

// ✅ Correct imports for standalone components
@Component({
  selector: 'app-user-card',
  template: `
    <form [formGroup]="userForm">
      <input formControlName="name" placeholder="Name">
      <button type="submit">Submit</button>
    </form>
  `,
  standalone: true,
  imports: [ReactiveFormsModule] // Required for form directives
})
export class UserCardComponent {
  userForm = new FormGroup({
    name: new FormControl('')
  });
}
```

### Common Import Patterns
```typescript
// Common imports for different template features
@Component({
  selector: 'app-feature',
  template: `
    <!-- CommonModule features -->
    <div *ngIf="showContent">Content</div>
    <div *ngFor="let item of items">{{ item.name }}</div>
    <div [ngClass]="{'active': isActive}">Class binding</div>
    
    <!-- ReactiveFormsModule features -->
    <form [formGroup]="form">
      <input formControlName="field">
    </form>
    
    <!-- RouterModule features -->
    <a routerLink="/home">Home</a>
    <router-outlet></router-outlet>
  `,
  standalone: true,
  imports: [
    CommonModule,        // For *ngIf, *ngFor, ngClass, etc.
    ReactiveFormsModule, // For formGroup, formControlName
    RouterModule         // For routerLink, router-outlet
  ]
})
export class FeatureComponent {
  showContent = true;
  items = [];
  isActive = true;
  form = new FormGroup({});
}
```

## Expression Diagnostics

### Template Expression Best Practices
```typescript
// ❌ Complex expressions in templates
@Component({
  template: `
    <div>{{ user.profile.settings.notifications.email.enabled ? 'Enabled' : 'Disabled' }}</div>
    <div>{{ items.filter(i => i.category === 'important').map(i => i.name).join(', ') }}</div>
  `
})
export class ComplexExpressionComponent {
  user = signal({});
  items = signal([]);
}

// ✅ Simplified expressions
@Component({
  template: `
    <div>{{ getEmailNotificationStatus() }}</div>
    <div>{{ getImportantItemNames() }}</div>
  `
})
export class SimplifiedExpressionComponent {
  user = signal({});
  items = signal([]);
  
  getEmailNotificationStatus(): string {
    const user = this.user();
    return user?.profile?.settings?.notifications?.email?.enabled ? 'Enabled' : 'Disabled';
  }
  
  getImportantItemNames(): string {
    return this.items()
      .filter(i => i.category === 'important')
      .map(i => i.name)
      .join(', ');
  }
}
```

## Type Safety Diagnostics

### Strict Template Type Checking
```typescript
// Enable strict template type checking
// tsconfig.json
{
  "angularCompilerOptions": {
    "strictTemplates": true,
    "strictInputTypes": true,
    "strictSafeNavigationTypes": true
  }
}

// ❌ Type unsafe template
@Component({
  template: `
    <div>{{ user.name.toUpperCase() }}</div>
    <div>{{ items[0].category }}</div>
  `
})
export class UnsafeTemplateComponent {
  user = signal<any>(null);
  items = signal<any[]>([]);
}

// ✅ Type safe template
@Component({
  template: `
    <div>{{ getUserName() }}</div>
    <div>{{ getFirstItemCategory() }}</div>
  `
})
export class SafeTemplateComponent {
  user = signal<User | null>(null);
  items = signal<Item[]>([]);
  
  getUserName(): string {
    const user = this.user();
    return user?.name?.toUpperCase() || '';
  }
  
  getFirstItemCategory(): string {
    const items = this.items();
    return items[0]?.category || '';
  }
}
```

## Performance Diagnostics

### Change Detection Optimization
```typescript
// ❌ Causes unnecessary change detection
@Component({
  template: `
    <div>{{ getCurrentTime() }}</div>
    <div>{{ Math.random() }}</div>
  `
})
export class PerformanceIssueComponent {
  getCurrentTime(): string {
    return new Date().toISOString(); // Creates new object every cycle
  }
}

// ✅ Optimized with signals
@Component({
  template: `
    <div>{{ currentTime() }}</div>
    <div>{{ randomValue() }}</div>
  `
})
export class OptimizedComponent {
  currentTime = signal(new Date().toISOString());
  randomValue = signal(Math.random());
  
  ngOnInit(): void {
    // Update time periodically
    setInterval(() => {
      this.currentTime.set(new Date().toISOString());
    }, 1000);
  }
}
```

## Common Error Patterns

### Signal Usage Errors
```typescript
// ❌ Incorrect signal usage
@Component({
  template: `<div>{{ user().name }}</div>`
})
export class IncorrectSignalUsage {
  user = signal<User | null>(null);
  
  ngOnInit(): void {
    // Don't call signals in constructor/ngOnInit
    console.log(this.user().name); // May be null
  }
}

// ✅ Correct signal usage
@Component({
  template: `<div>{{ getUserName() }}</div>`
})
export class CorrectSignalUsage {
  user = signal<User | null>(null);
  
  getUserName(): string {
    const user = this.user();
    return user?.name || '';
  }
  
  ngOnInit(): void {
    // Use effect for reactive operations
    effect(() => {
      const user = this.user();
      if (user) {
        console.log('User loaded:', user.name);
      }
    });
  }
}
```

### Dependency Injection Errors
```typescript
// ❌ Incorrect injection
@Component({
  template: `<div>{{ data }}</div>`
})
export class IncorrectInjection {
  private service = new DataService(); // Don't use 'new'
}

// ✅ Correct injection
@Component({
  template: `<div>{{ data() }}</div>`
})
export class CorrectInjection {
  private service = inject(DataService);
  data = signal<any>(null);
}
```

## Diagnostic Configuration

### Angular.json Configuration
```json
{
  "projects": {
    "my-app": {
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:application",
          "options": {
            "extractLicenses": false,
            "optimization": false,
            "sourceMap": true,
            "namedChunks": true
          }
        },
        "lint": {
          "builder": "@angular-eslint/builder:lint",
          "options": {
            "lintFilePatterns": [
              "src/**/*.ts",
              "src/**/*.html"
            ]
          }
        }
      }
    }
  }
}
```

### ESLint Configuration
```json
{
  "extends": [
    "@angular-eslint/recommended",
    "@angular-eslint/template/process-inline-templates"
  ],
  "rules": {
    "@angular-eslint/no-empty-lifecycle-method": "error",
    "@angular-eslint/use-lifecycle-interface": "error",
    "@angular-eslint/component-class-suffix": "error",
    "@angular-eslint/directive-class-suffix": "error"
  }
}
```

## Testing Diagnostics

### Test Setup Diagnostics
```typescript
// ❌ Missing test setup
describe('Component', () => {
  it('should work', () => {
    const component = new MyComponent();
    expect(component).toBeTruthy();
  });
});

// ✅ Proper test setup
describe('MyComponent', () => {
  let component: MyComponent;
  let fixture: ComponentFixture<MyComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [MyComponent]
    }).compileComponents();

    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
```

## Best Practices

### Do's
- Enable strict template type checking
- Use proper imports for standalone components
- Keep template expressions simple and clear
- Use signals for reactive state management
- Follow dependency injection patterns
- Write comprehensive tests

### Don'ts
- Don't use complex expressions in templates
- Don't create new objects in template expressions
- Don't use 'new' for service instantiation
- Don't ignore TypeScript strict mode warnings
- Don't skip import statements for standalone components
- Don't use any type without proper justification