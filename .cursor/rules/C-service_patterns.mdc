---
description: Service layer patterns - business logic and state management
alwaysApply: false
---

# Service Patterns

Services manage state with Signals and business logic. **Prerequisites**: Read @A-coding_patterns first.

**Important** Create a documentation file next to service after implement

## Core Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class ExampleService {
  private api = inject(ExampleApi);
  
  // State (private)
  private readonly selectedId = signal<string | null>(null);
  
  // Resources (follow @rule:resource-selection below)
  private readonly listResource = rxResource<Item[], ApiError>({
    stream: () => from(this.api.getItems())
  });
  
  // Public signals (computed, typed)
  readonly items = computed<Item[]>(() => this.listResource.value() ?? []);
  readonly isLoading = computed<boolean>(() => this.listResource.isLoading());
  readonly error = computed<ApiError | null>(() => this.listResource.error() ?? null);
  
  // Actions
  async create(data: CreateDto): Promise<Item> {
    try {
      const item = await this.api.create(data);
      this.listResource.reload();
      return item;
    } catch (error) {
      // Error handling: @error_handling_patterns#service-errors
      throw error;
    }
  }
}
```

## Resource Selection {#resource-selection}

| Use | When |
|-----|------|
| `rxResource` | Wrapping Promises with `from()` |
| `resource` | Direct async/Promise calls |
| `toSignal` | Simple Observable conversion |

## Required Cross-Cutting Concerns

- **Error Types**: Import from @error_handling_patterns#error-types
- **Error Handling**: Follow @error_handling_patterns#service-errors
- **Testing**: See @testing_patterns#service-tests
- **Validation**: Use @data_modeling_patterns#validation

## Service Checklist
- [ ] Injects only corresponding API
- [ ] Uses typed computed signals
- [ ] Follows error patterns from central doc
- [ ] Consolidates loading states
- [ ] Implements validation before API calls