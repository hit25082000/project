---
description: template syntax including exponentiation operator and new features
globs:
alwaysApply: false
---

# Angular 20 Template Syntax

Angular 20 introduces enhanced template syntax with support for the exponentiation operator (`**`), tagged template literals, and the `in` operator for more expressive and concise code.

## New Template Operators (Angular 20)

### Exponentiation Operator
```html
<!-- Angular 20: Exponentiation operator -->
<div class="math-operations">
  <p>2 to the power of 3: {{ 2 ** 3 }}</p>
  <p>Base: {{ base() }}, Exponent: {{ exponent() }}</p>
  <p>Result: {{ base() ** exponent() }}</p>
  
  <!-- Dynamic calculations -->
  <p>Area of square: {{ side() ** 2 }}</p>
  <p>Volume of cube: {{ side() ** 3 }}</p>
</div>
```

### In Operator
```html
<!-- Angular 20: In operator for object property checking -->
<div class="property-checking">
  <p>Has 'name' property: {{ 'name' in user() }}</p>
  <p>Has 'email' property: {{ 'email' in user() }}</p>
  
  <!-- Dynamic property checking -->
  <div class="user-properties">
    @for (prop of ['name', 'email', 'phone']; track prop) {
      <span [class.available]="prop in user()">
        {{ prop }}: {{ prop in user() ? 'Available' : 'Missing' }}
      </span>
    }
  </div>
</div>
```

### Tagged Template Literals
```html
<!-- Angular 20: Tagged template literals support -->
<div class="template-literals">
  <!-- SQL-like queries -->
  <p>{{ sql`SELECT * FROM users WHERE id = ${userId()}` }}</p>
  
  <!-- Styled text -->
  <p>{{ styled`Hello ${name()}!` }}</p>
  
  <!-- Localized strings -->
  <p>{{ i18n`Welcome back, ${userName()}!` }}</p>
</div>
```

## Enhanced Control Flow

### Advanced @if Conditions
```html
<!-- Complex conditions with new operators -->
<div class="conditional-rendering">
  @if (user() && 'admin' in user().roles) {
    <admin-panel [user]="user()" />
  }
  
  @if (count() > 0 && count() ** 2 < 100) {
    <div class="count-display">
      Count: {{ count() }}, Squared: {{ count() ** 2 }}
    </div>
  }
  
  @if ('settings' in user().preferences && user().preferences.settings.enabled) {
    <settings-panel [settings]="user().preferences.settings" />
  }
</div>
```

### Enhanced @for with New Operators
```html
<!-- Advanced list rendering -->
<div class="enhanced-loops">
  <!-- Power calculations in loops -->
  @for (number of numbers(); track number) {
    <div class="number-item">
      {{ number }}² = {{ number ** 2 }}, {{ number }}³ = {{ number ** 3 }}
    </div>
  }
  
  <!-- Property existence checking -->
  @for (item of items(); track item.id) {
    <div class="item" [class.has-description]="'description' in item">
      <h3>{{ item.name }}</h3>
      @if ('description' in item) {
        <p>{{ item.description }}</p>
      }
      @if ('tags' in item && item.tags.length > 0) {
        <div class="tags">
          @for (tag of item.tags; track tag) {
            <span class="tag">{{ tag }}</span>
          }
        </div>
      }
    </div>
  }
</div>
```

## Template Expression Optimization

### Computed Expressions
```html
<!-- Efficient template expressions -->
<div class="optimized-expressions">
  <!-- Use computed signals for complex calculations -->
  <div class="statistics">
    <p>Total: {{ total() }}</p>
    <p>Average: {{ average() }}</p>
    <p>Standard Deviation: {{ standardDeviation() }}</p>
    
    <!-- Power calculations -->
    <p>Variance: {{ variance() }}</p>
    <p>Sum of Squares: {{ sumOfSquares() }}</p>
  </div>
  
  <!-- Conditional power operations -->
  @if (enableAdvancedMath()) {
    <div class="advanced-math">
      <p>Exponential Growth: {{ base() ** time() }}</p>
      <p>Compound Interest: {{ principal() * (1 + rate()) ** years() }}</p>
    </div>
  }
</div>
```

### Safe Property Access
```html
<!-- Safe property access with in operator -->
<div class="safe-access">
  @if (user() && 'profile' in user()) {
    <div class="user-profile">
      @if ('avatar' in user().profile) {
        <img [src]="user().profile.avatar" [alt]="user().profile.name" />
      }
      
      @if ('bio' in user().profile && user().profile.bio.length > 0) {
        <p class="bio">{{ user().profile.bio }}</p>
      }
    </div>
  }
  
  <!-- Dynamic property access -->
  @for (field of profileFields(); track field.key) {
    @if (field.key in user().profile) {
      <div class="profile-field">
        <label>{{ field.label }}:</label>
        <span>{{ user().profile[field.key] }}</span>
      </div>
    }
  }
</div>
```

## Custom Template Functions

### Math Functions
```typescript
// Custom template functions for enhanced calculations
export class MathTemplateFunctions {
  static power(base: number, exponent: number): number {
    return base ** exponent;
  }
  
  static squareRoot(value: number): number {
    return Math.sqrt(value);
  }
  
  static hasProperty(obj: any, property: string): boolean {
    return property in obj;
  }
}
```

```html
<!-- Using custom template functions -->
<div class="math-functions">
  <!-- Custom power function -->
  <p>Custom Power: {{ power(3, 4) }}</p>
  
  <!-- Square root -->
  <p>Square Root of 16: {{ squareRoot(16) }}</p>
  
  <!-- Property checking -->
  <p>Has Property: {{ hasProperty(user(), 'email') }}</p>
</div>
```

### String Template Functions
```typescript
// Template functions for string manipulation
export class StringTemplateFunctions {
  static formatCurrency(amount: number, currency = 'USD'): string {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: currency
    }).format(amount);
  }
  
  static formatDate(date: Date, locale = 'en-US'): string {
    return new Intl.DateTimeFormat(locale).format(date);
  }
  
  static truncate(text: string, length: number): string {
    return text.length > length ? text.substring(0, length) + '...' : text;
  }
}
```

## Advanced Template Patterns

### Dynamic Component Loading with New Syntax
```html
<!-- Dynamic component creation with enhanced syntax -->
<div class="dynamic-components">
  @if (componentType() && componentType() in availableComponents()) {
    <ng-container 
      [ngComponentOutlet]="availableComponents()[componentType()]"
      [ngComponentOutletInputs]="getComponentInputs()">
    </ng-container>
  }
  
  <!-- Power-based conditional rendering -->
  @if (userLevel() ** 2 >= 100) {
    <premium-features [user]="user()" />
  }
</div>
```

### Form Validation with Enhanced Syntax
```html
<!-- Enhanced form validation templates -->
<form [formGroup]="userForm" class="enhanced-form">
  <div class="form-group">
    <label for="name">Name:</label>
    <input 
      id="name" 
      formControlName="name"
      [class.error]="'name' in formErrors()"
      placeholder="Enter your name"
    />
    @if ('name' in formErrors()) {
      <div class="error-message">{{ formErrors().name }}</div>
    }
  </div>
  
  <div class="form-group">
    <label for="age">Age:</label>
    <input 
      id="age" 
      type="number"
      formControlName="age"
      [class.error]="'age' in formErrors()"
    />
    @if ('age' in formErrors()) {
      <div class="error-message">{{ formErrors().age }}</div>
    }
  </div>
  
  <!-- Dynamic validation messages -->
  @for (field of formFields(); track field.name) {
    @if (field.name in formErrors()) {
      <div class="field-error">
        {{ field.label }}: {{ formErrors()[field.name] }}
      </div>
    }
  }
</form>
```

## Performance Considerations

### Efficient Template Expressions
```html
<!-- Optimized template expressions -->
<div class="performance-optimized">
  <!-- Use computed signals instead of complex expressions -->
  <div class="user-stats">
    <p>Total Score: {{ totalScore() }}</p>
    <p>Average Score: {{ averageScore() }}</p>
    <p>Score Squared: {{ scoreSquared() }}</p>
  </div>
  
  <!-- Avoid repeated calculations -->
  @if (isHighPerformer()) {
    <div class="achievement">
      <h3>High Performer!</h3>
      <p>Score: {{ totalScore() }}</p>
      <p>Rank: {{ calculateRank() }}</p>
    </div>
  }
</div>
```

### Template Optimization Best Practices
```typescript
// Component with optimized computed signals
@Component({
  template: `
    <div class="optimized-component">
      @if (shouldShowContent()) {
        <div class="content">
          <h2>{{ formattedTitle() }}</h2>
          <p>{{ truncatedDescription() }}</p>
          <div class="metrics">
            <span>Power: {{ powerValue() }}</span>
            <span>Has Property: {{ hasRequiredProperty() }}</span>
          </div>
        </div>
      }
    </div>
  `
})
export class OptimizedComponent {
  title = signal('Sample Title');
  description = signal('Long description that might need truncation');
  baseValue = signal(2);
  exponentValue = signal(3);
  data = signal<any>({});
  
  // Computed signals for performance
  shouldShowContent = computed(() => this.data() && Object.keys(this.data()).length > 0);
  formattedTitle = computed(() => this.title().toUpperCase());
  truncatedDescription = computed(() => 
    this.description().length > 100 
      ? this.description().substring(0, 100) + '...'
      : this.description()
  );
  powerValue = computed(() => this.baseValue() ** this.exponentValue());
  hasRequiredProperty = computed(() => 'required' in this.data());
}
```

## Template Testing

### Testing New Template Features
```typescript
describe('TemplateSyntaxComponent', () => {
  let component: TemplateSyntaxComponent;
  let fixture: ComponentFixture<TemplateSyntaxComponent>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TemplateSyntaxComponent]
    }).compileComponents();
    
    fixture = TestBed.createComponent(TemplateSyntaxComponent);
    component = fixture.componentInstance;
  });
  
  it('should display exponentiation results', () => {
    component.base.set(3);
    component.exponent.set(2);
    fixture.detectChanges();
    
    const compiled = fixture.nativeElement;
    expect(compiled.textContent).toContain('9'); // 3 ** 2 = 9
  });
  
  it('should check property existence', () => {
    component.user.set({ name: 'John', email: 'john@example.com' });
    fixture.detectChanges();
    
    const compiled = fixture.nativeElement;
    expect(compiled.textContent).toContain('Has \'name\' property: true');
    expect(compiled.textContent).toContain('Has \'phone\' property: false');
  });
});
```

## Migration Guide

### Updating Existing Templates
```html
<!-- Before: Complex expressions -->
<div class="old-syntax">
  <p>Result: {{ Math.pow(base, exponent) }}</p>
  <p>Has Property: {{ user.hasOwnProperty('email') }}</p>
</div>

<!-- After: Angular 20 syntax -->
<div class="new-syntax">
  <p>Result: {{ base ** exponent }}</p>
  <p>Has Property: {{ 'email' in user }}</p>
</div>
```

### Best Practices for New Syntax
- Use `**` operator for mathematical power operations
- Use `in` operator for property existence checking
- Leverage tagged template literals for specialized string formatting
- Combine new operators with control flow for more expressive templates
- Maintain readability while using new features
- Test thoroughly when migrating existing templates