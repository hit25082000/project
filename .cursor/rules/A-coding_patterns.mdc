---
description: Global architectural, quality, and security standards for the entire codebase
alwaysApply: false
---

# General Coding Patterns

This file is the single source of truth for cross-cutting architectural and quality rules. Other rule documents must reference this guide instead of restating its content.

## Code Organization Principles

### Separation of Concerns
- **Presentation Layer**: Components handle UI and user interactions
- **State Layer**: Services manage application state and business logic  
- **Data Layer**: APIs handle backend communication

### Dependency Flow
```
Components → Services → APIs → Supabase
```

### Signal-Based Architecture
- Use Angular Signals for all state management
- Avoid manual subscription management
- Leverage `computed()` for derived state
- Use `resource()` for async data loading
- **FORBIDDEN**: `effect()` in components for form state management
- **REQUIRED**: Use `computed()` for reactive form updates

### Directory Structure Principles

The project uses a modular structure to keep concerns separated and scalable.

#### Directory Architecture and Organization

* **`/core` – Core System**: Application-wide logic that loads once.
  ```
  core/
  ├── guards/      # Authentication and authorization guards
  ├── pages/       # System-level pages (e.g., 404 Not Found)
  └── layout/      # Main application layouts (shells with navbars)
  ```

* **`/shared` – Shared Resources**: Reusable code that is business-agnostic.
  ```
  shared/
  ├── components/  # Shared, business-aware components
  ├── constants/   # Global constants
  └── services/    # Global services (e.g., notification service)
  ```

* **`/widget` – UI Widgets**: Generic, presentation-only components.
  ```
  widget/
  ├── components/  # Reusable UI components (e.g., v-button, v-card)
  ├── directives/  # Custom attribute or structural directives
  └── pipes/       # Custom data transformation pipes
  ```

* **`/domain` – Business Modules**: One folder per business domain.
  ```
  domain/
  ├── auth/
  └── establishment/
      ├── apis/
      ├── components/
      ├── services/
      ├── interfaces/
      ├── pages/
      └── ...
  ```

#### File Placement Rules

> Domain-specific files (`constants`, `dialogs`, etc.) **must** be placed inside their respective domain folder. If a resource needs to be used by more than one domain, it should be moved to the `/shared` folder. If it is a purely presentational UI component, it belongs in `/widget`.

### Naming Conventions

**File Naming**: `kebab-case` with format `feature.type.ts`
- Components: `[feature]-[type].component.ts` (e.g., `user-profile.page.ts`)
- Services: `[feature].service.ts` (e.g., `user.service.ts`)
- APIs: `[feature].api.ts` (e.g., `user.api.ts`)

**Class Naming**: PascalCase
- Services: `[Feature]Service` (e.g., `UserService`)
- Components: `[Feature][Type]Component` (e.g., `UserProfilePage`)
- Interfaces: `i[Feature]` (e.g., `iUser`)

**Selectors**: 
- Pages: `app-[feature]-[action]` (e.g., `<app-user-profile>`)
- Reusable: `v-[feature]-[type]` (e.g., `<v-user-card>`)

**Variables**: camelCase (e.g., `selectedUser`, `isLoading`)
**Constants**: SCREAMING_SNAKE_CASE (e.g., `USER_FORM_CONFIG`)
**Database**: snake_case (e.g., `user_profile`)
**CSS**: BEM methodology (e.g., `.user-card__title`)

### Referencing This Guide
- Component, service, and API pattern files should link back here for shared rules on signals, layering, security, directory structure, and naming conventions
- Update this document first whenever a global rule changes, then adjust downstream references

## Code Quality Standards

### TypeScript Usage
- Use strict type checking
- Prefer interfaces over types for object shapes
- Use utility types (`Pick`, `Omit`, `Partial`) for type variations
- **FORBIDDEN**: `any` type usage including `$any()` in templates
- **REQUIRED**: Proper type assertions with `as` keyword

### Performance Considerations
- Use `OnPush` change detection strategy
- Implement lazy loading for modules
- Use `trackBy` functions in `@for` loops
- Optimize bundle size with tree shaking

### Security Best Practices
- Validate all user inputs
- Sanitize data before rendering
- Use proper authentication guards
- Implement proper authorization checks

## Rule Enforcement

### Pre-Implementation Checklist
- [ ] Read this guide as prerequisite for all component patterns
- [ ] Verify signal-based architecture compliance
- [ ] Confirm TypeScript strict typing
- [ ] Check separation of concerns
- [ ] Validate performance considerations
- [ ] Verify proper directory structure placement
- [ ] Confirm naming conventions compliance

### Post-Implementation Validation
- [ ] No `effect()` in components for form state
- [ ] No `$any()` type assertions in templates
- [ ] Proper type assertions with `as` keyword
- [ ] OnPush change detection used
- [ ] Signal-based state management implemented
- [ ] Files placed in correct directory structure
- [ ] All naming conventions followed consistently