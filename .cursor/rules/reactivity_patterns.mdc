---
description: Angular 20 signal-based reactivity patterns and state management
globs:
alwaysApply: false
---

# Angular 20 Reactivity Patterns

Angular 20 stabilizes the Signals API. Review `A-coding_patterns.mdc` for global guidance on using Signals across the application.

## Core Signal Patterns

> Global rules: `A-coding_patterns.mdc` (architecture) · `C-service_patterns.mdc` (state) · `C-component_patterns.mdc` (exposed Signals)

### Basic Signal Usage
```typescript
// Creating signals
readonly count = signal(0);
readonly name = signal<string>('');
readonly items = signal<string[]>([]);

// Computed signals
readonly doubleCount = computed(() => this.count() * 2);
readonly itemCount = computed(() => this.items().length);
readonly hasItems = computed(() => this.items().length > 0);

// Writable signals with updates
increment(): void {
  this.count.update(value => value + 1);
}

addItem(item: string): void {
  this.items.update(items => [...items, item]);
}

clearItems(): void {
  this.items.set([]);
}
```

### Resource Pattern for Async Data
```typescript
@Injectable({ providedIn: 'root' })
export class DataService {
  private api = inject(DataApi);
  
  // Resource for async data loading
  private readonly dataResource = resource({
    request: () => this.trigger(),
    loader: () => this.api.getData(),
  });
  
  readonly data = toSignal(this.dataResource.value, { initialValue: [] });
  readonly loading = toSignal(this.dataResource.loading);
  readonly error = toSignal(this.dataResource.error);
  
  // Trigger for refetching
  private trigger = signal(0);
  
  refresh(): void {
    this.trigger.update(v => v + 1);
  }
}
```

## Advanced Signal Patterns

### Linked Signals (Angular 20)
```typescript
export class FormService {
  // Primary signal
  readonly formData = signal<iFormData>({
    name: '',
    email: '',
    age: 0
  });
  
  // Linked signals for individual fields
  readonly name = linkedSignal(
    () => this.formData().name,
    (value) => this.updateField('name', value)
  );
  
  readonly email = linkedSignal(
    () => this.formData().email,
    (value) => this.updateField('email', value)
  );
  
  private updateField(field: keyof iFormData, value: any): void {
    this.formData.update(data => ({ ...data, [field]: value }));
  }
}
```

### Effect Patterns (Angular 20)
```typescript
@Injectable({ providedIn: 'root' })
export class EffectService {
  private logger = inject(LoggerService);
  
  constructor() {
    // Effect for logging state changes
    effect(() => {
      const currentUser = this.user();
      if (currentUser) {
        this.logger.log('User logged in:', currentUser.id);
      }
    });
    
    // Effect with cleanup
    effect((onCleanup) => {
      const subscription = this.setupWebSocket();
      
      onCleanup(() => {
        subscription.unsubscribe();
      });
    });
  }
  
  readonly user = signal<User | null>(null);
}
```

## Signal-Based Component Patterns

> Consulte `C-component_patterns.mdc` para papéis de smart/dumb components

### Smart Component with Signals
```typescript
@Component({
  template: `
    <div class="user-profile">
      @if (isLoading()) {
        <v-loading-spinner />
      } @else if (user()) {
        <v-user-card [user]="user()!" />
        <button (click)="editProfile()">Edit Profile</button>
      } @else {
        <v-error-message [error]="error()" />
      }
    </div>
  `
})
export class UserProfilePage {
  private userService = inject(UserService);
  
  // Direct signal exposure
  user = this.userService.selectedUser;
  isLoading = this.userService.isLoading;
  error = this.userService.error;
  
  editProfile(): void {
    this.userService.startEdit();
  }
}
```

### Dumb Component with Signals
```typescript
@Component({
  selector: 'v-user-card',
  template: `
    <div class="user-card">
      <h3>{{ user().name }}</h3>
      <p>{{ user().email }}</p>
      <span class="status" [class.active]="user().isActive">
        {{ user().isActive ? 'Active' : 'Inactive' }}
      </span>
    </div>
  `
})
export class UserCardComponent {
  user = input.required<User>();
}
```

## Signal Interop Patterns

> Integrar com observables conforme diretrizes de interoperabilidade em `A-coding_patterns.mdc`

### Converting Observables to Signals
```typescript
@Injectable({ providedIn: 'root' })
export class SignalInteropService {
  private http = inject(HttpClient);
  
  // Convert HTTP observable to signal
  readonly users = toSignal(
    this.http.get<User[]>('/api/users'),
    { initialValue: [] }
  );
  
  // Convert observable with error handling
  readonly data = toSignal(
    this.http.get<Data>('/api/data').pipe(
      catchError(error => of(null))
    ),
    { initialValue: null }
  );
  
  // Manual observable to signal conversion
  private dataSubject = new BehaviorSubject<Data | null>(null);
  readonly manualData = toSignal(this.dataSubject.asObservable());
}
```

### Converting Signals to Observables
```typescript
export class ObservableInteropService {
  readonly count = signal(0);
  readonly name = signal('');
  
  // Convert signal to observable
  count$ = toObservable(this.count);
  name$ = toObservable(this.name);
  
  // Combined observable from signals
  combined$ = combineLatest({
    count: this.count$,
    name: this.name$
  });
}
```

## Performance Optimization with Signals

> Use em conjunto com `performance_optimization.mdc`

### Computed Signal Optimization
```typescript
export class OptimizedService {
  readonly items = signal<Item[]>([]);
  readonly filter = signal<string>('');
  readonly sortBy = signal<keyof Item>('name');
  
  // Optimized computed - only recalculates when dependencies change
  readonly filteredAndSortedItems = computed(() => {
    const items = this.items();
    const filter = this.filter().toLowerCase();
    const sortBy = this.sortBy();
    
    return items
      .filter(item => item.name.toLowerCase().includes(filter))
      .sort((a, b) => a[sortBy].localeCompare(b[sortBy]));
  });
  
  // Memoized expensive computation
  readonly expensiveComputation = computed(() => {
    const items = this.filteredAndSortedItems();
    return this.performExpensiveOperation(items);
  });
  
  private performExpensiveOperation(items: Item[]): ProcessedItem[] {
    // Expensive operation that benefits from memoization
    return items.map(item => this.processItem(item));
  }
}
```

### Signal Cleanup Patterns
```typescript
@Injectable({ providedIn: 'root' })
export class CleanupService {
  private cleanupFunctions: (() => void)[] = [];
  
  setupReactiveCleanup(): void {
    effect((onCleanup) => {
      const subscription = interval(1000).subscribe(() => {
        this.performPeriodicTask();
      });
      
      onCleanup(() => {
        subscription.unsubscribe();
        console.log('Cleanup performed');
      });
    });
  }
  
  private performPeriodicTask(): void {
    // Periodic task implementation
  }
}
```

## Signal Testing Patterns

### Testing Signal-Based Services
```typescript
describe('SignalService', () => {
  let service: SignalService;
  
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [SignalService]
    });
    service = TestBed.inject(SignalService);
  });
  
  it('should update signal values', () => {
    service.setCount(5);
    expect(service.count()).toBe(5);
    
    service.increment();
    expect(service.count()).toBe(6);
  });
  
  it('should compute derived values', () => {
    service.setCount(3);
    expect(service.doubleCount()).toBe(6);
  });
  
  it('should handle async operations with resource', async () => {
    const mockData = [{ id: 1, name: 'Test' }];
    spyOn(service['api'], 'getData').and.returnValue(Promise.resolve(mockData));
    
    service.refresh();
    await fixture.whenStable();
    
    expect(service.data()).toEqual(mockData);
    expect(service.loading()).toBeFalse();
  });
});
```

### Testing Signal Effects
```typescript
describe('EffectService', () => {
  let service: EffectService;
  let loggerSpy: jasmine.Spy;
  
  beforeEach(() => {
    loggerSpy = jasmine.createSpy('log');
    TestBed.configureTestingModule({
      providers: [
        EffectService,
        { provide: LoggerService, useValue: { log: loggerSpy } }
      ]
    });
    service = TestBed.inject(EffectService);
  });
  
  it('should trigger effect when user changes', () => {
    const user = { id: 1, name: 'Test User' };
    service.user.set(user);
    
    expect(loggerSpy).toHaveBeenCalledWith('User logged in:', 1);
  });
});
```

## Signal Best Practices

### Do's
- Use signals for all reactive state management
- Prefer computed signals for derived state
- Use effects sparingly and with proper cleanup
- Leverage resource() for async data loading
- Use toSignal() for observable interop

### Don'ts
- Don't mix signals with RxJS for state management
- Don't create effects without proper cleanup
- Don't use signals for one-time operations
- Don't access signals outside of injection context
- Don't forget to handle errors in async operations

### Performance Tips
- Use computed signals to avoid unnecessary recalculations
- Batch signal updates when possible
- Use untracked() for non-reactive operations within effects
- Prefer readonly signals when data shouldn't be modified
- Use linkedSignal() for two-way binding scenarios